/*
 *  한틀아리 자료틀 머리 파일
 *  이 자료틀에서 가장 근간이 되는 머리 파일
 *  handbms.h
 */

#ifndef DBERROR
#define DBERROR   -1
#define DBOK       0
#endif

#ifndef TRUE
#define TRUE     1
#define FALSE    0
#endif

#include <ctype.h>

extern int errno;

#include <sys\stat.h>
#include <fcntl.h>
#include <io.h>
#include "typedefs.h"

#define OPENMODE  O_RDWR+O_BINARY
#define CMODE     S_IWRITE

#define NODE 512           /* B-트리 노드의 길이  */
#define RPTR long		     /* B-트리 노드번호와 자료파일의 자료번호의 형
                            long형이면 2의 32승개까지 가능 */

#define MAXFILS   50	     /* 자료틀안의 최대 파일 수 */
#define MAXELE    300	     /* 시스템의 최대 자료 요소수 */
#define MAXINDEX  20         /* 파일당 최대 인덱스 수		*/

#define MAXUPDATEFUNC  20  /* browse -> update 에서 불릴 함수의 최대갯수 */

/* 질의부의 기능키 정의 */
#define HELPKEY    F1        /* 도움말 */
#define MENUKEY    F10       /* 차림표 */
#define SAVEKEY    F2        /* 자료 저장 */
#define UNDOKEY    F5        /* 자료를 원래대로 */
#define OUTPUTKEY  F7        /* 자료 출력 */
#define DELETEKEY  F8        /* 자료 지우기 */
#define CANCELKEY  ESC       /* 취소   */
#define QUITKEY    ESC       /* 끝내기 */

#define ABORTKEY   -1        /* 실제 자판에서 눌리는 키가 아니다. */

/* 자료 열람에 쓰는 기능 키 정의 */
#define FINDKEY    ALT_S     /* 자료 찾기 */
#define DELETEKEY  F8        /* 자료 지우기 */


/* 질의부의 화면 구성 정의 */
/* #define BUTTON_GAP  (2)  */       /* 제어판에 있는 각 단추 사이의 거리 */
/* #define BUTTON_CTR  (8)  */       /* 제어판에 있는 단추의 갯수 */
/* #define BUTTON_Y    (24) */       /* 단추들의 y좌표 */
#define STATUS_Y    (25)             /* 상태 표시 줄의 y좌표 */
#define TITLE_Y     (1)              /* 질의부의 화면 제목의 y좌표 */
#define CARDWIDTH   (78)             /* 입력 화면에서 최대 넓이 */

/* 잘못번호(errno)를 돌려주기 위한 자료틀 잘못 부호 */
#define D_NF	    1	       /* record not found; 레코드 못 찾음 */
#define D_PRIOR	  2	       /* no prior record for this request;
                              이 요구를 위해 얻어둔 레코드 없음 */
#define D_EOF	    3	       /* end of file; 파일 끝	*/
#define D_BOF	    4	       /* beginning of file; 파일의 시작  */
#define D_DUPL	  5	       /* primary key already exists; 주키가 이미 존재 */
#define D_OM	    6	       /* out of memory; 기억소 부족 */
#define D_INDXC   7        /* index corrupted; 인덱스 깨짐 */
#define D_IOERR	  8        /* i/o error; 입출력 잘못 */

#define MAXKEYLEN 80	     /* 인덱스를 위한 최대 키 길이 */

/* qd(질의함수)의 사용에서 그 용도를 밝히기 위해 */
#define DBUPDATE  0        /* 수정 상태 */
#define DBINPUT   1        /* 입력 상태 */

/* browse의 상태
  (1) Browse mode --> Update
  (2) Browse mode --> Ref */
#define B2UPDATE  0
#define B2REF     1

/* 키값 찾기 상태 */
#define DB_EXACT    0     /* 정확한 키값을 검색한다. 자료 입출력에서는 필수적 */
#define DB_NOEXACT  1     /* 키값의 길이만큼만 검색한다. 자료 검색에 유용하다 */

/* 자료 출력 방향 설정 */
#define DATA2PRN    0
#define DATA2FILE   1

#ifndef HANSCHEMA

/* 응용풀그림을 위해 구축된 스키마  */
extern char *dbfiles [];		/* 자료틀 파일이름 */
extern char *denames [];		/* 영문 자료요소 이름 */
extern char *hdenames [];		/* 한글 자료요소 이름 */
extern char *elmask  [];		/* 자료요소 마스크 */
extern char eltype [];			/* 자료요소 형 */
extern int ellen [];			  /* 자료요소의 길이 */
extern int *file_ele [];		/* 파일에 포함된 자료요소의 번호 */
extern int **index_ele [];	/* 인덱스된 자료요소 번호 */

extern void (*browse2update[])(int, char*);

/* 자료처리를 위한 버퍼 */
extern char *rb, *sc;

/* 자료파일의 머리 */
typedef struct fhdr	{
	RPTR first_record;
	RPTR next_record;
  RPTR total_record;
	int record_length;
} FHEADER;

/* 입력받을 자료요소의 좌표 */
struct coord_t {
  int x, y;
};

void mov_mem(), set_mem(), fatal();
void cls_file();
void build_b();
void put_char(), clear_screen(), cursor();
void error_message(), clear_notice(), post_notice();

/* ------------------ handuitl.c --------------------- */
int db_init(void);

/* ------------------ hanstr.c ---------------------- */
char            *str_trim(char *str);
char            *ins_left_space(char *str, int len);
char            *ins_left_zero(char *str, int len);
char            *ins_right_space(char *str, int len);

/* ------------------ handfile.c -----------------------*/
int             file_create(char *name, int len);
int             file_open(char *name);
void            file_close(int fp);
RPTR            get_total_record(int fp);
RPTR            new_record(int fp, char *buf);
int             get_record(int fp, RPTR rcdno, char *buf);
int             put_record(int fp, RPTR rcdno, char *buf);
int             delete_record(int fp, RPTR rcdno);

/* ------------------- hanbtree.c ----------------------*/
int             btree_init(char *ndx_name);
int             btree_close(int tree);
void            build_b(char *name, int len);
RPTR            locate(int tree, char *k, int find_mode);
int             deletekey(int  tree, char *x, RPTR ad);
int             insertkey(int tree, char *x, RPTR ad, int unique);
RPTR            nextkey(int tree);
RPTR            prevkey(int tree);
RPTR            firstkey(int tree);
RPTR            lastkey(int tree);
void            keyval(int tree, char *ky);
RPTR            currkey(int tree);

/* -------------------- handbase.c ---------------------*/
void            db_open(char *path, int *fl);
int             add_rcd(int fileno, char *buf);
int             find_rcd(int fileno, int keyno, char *keyvalue, char *buf, int find_mode);
int             verify_rcd(int fileno, int keyno, char *keyvalue, int find_mode);
int             first_rcd(int fileno, int keyno, char *buf);
int             last_rcd(int fileno, int keyno, char *buf);
int             next_rcd(int fileno, int keyno, char *buf);
int             prev_rcd(int fileno, int keyno, char *buf);
int             rtn_rcd(int fileno, char *buf);
int             del_rcd(int fileno);
int             curr_rcd(int fileno, int keyno, char *buf);
int             seqrcd(int fileno, RPTR *buf);
void            db_close(int *fl);
void            db_allclose(void);
int             rlen(int fileno);
void            clrrcd(char *buf, int *els);
void            init_rcd(int fileno, char *buf);
void            rcd_fill(char *sourse, char *destin, int *sourcelist, int *destinlist);
int             epos(int elementno, int *list);
void            dberror(void);
void            mov_mem(char *s, char *d, int l);
void            set_mem(char *s, int l, char n) ;

void            rebuild_index(int file_no, int allflag);
void            build_index(char *path, int fileno);
int             add_indexes(int fileno, char *buf, RPTR ad);
int             filename(char *fn);
void            name_cvt(char *c2, char *c1);

/*---------------------------- hanquery.c ------------------------- */
void            db_input(int file_no, char *title, int data_ele[], struct coord_t crd[]);
void            db_search(int file_no, char *title, int data_ele[], struct coord_t crd[], int keyno, char *keyvalue, int find_mode);
void            db_update(int file_no, char *title, int data_ele[], struct coord_t crd[], int key, char *buf);
void            db_delete(int file_no, char *title, int data_ele[], struct coord_t crd[], int keyno, char *keyvalue);
char            *db_browse(int file_no, char *title, int data_ele[], int key_no, int mode);
int             *get_print_list(int file_no, char *title, int data_ele[], struct coord_t crd[], int prn_list[]);
void            db_print(int file_no, char *title, int data_ele[], int key_no, int mode);

/* ---------------------------- hanscrn.c --------------------------- */
void            post_notice(char *s);
void            clear_scrn(void);
void            init_screen(char *name, int *els, char *bfr);
void            protect(int el, int tf);
void            edit(int el, int (*func)());
void            mark_pannel(int butt_ctr);
void            display_template(char *title, int menu_flag);
bool            hookhgetdata(int *keycodep);
int             data_entry(char *pkey, int file);
int             *get_ele_list(int ele_list[]);
char            *del_comma(char *str);
char            *ins_comma(char *str);
byte            *pickoutdata(byte *buffer, byte *format, byte *data);
int             spaces(char *c);
void            tally(void);
void            put_field(int el);
void            disp_record_status(int file_no, RPTR cur_rec);
void            disp_record_number(int file_no, RPTR cur_rec);

#endif

